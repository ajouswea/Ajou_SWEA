# [모의 SW 역량테스트] 탈주범 검거

> [알고리즘 분류],[문제 URI](https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AV6kld8aisgDFASb&contestProbId=AV5PpLlKAQ4DFAUq&probBoxId=AV732SG66sEDFAW7&type=PROBLEM&problemBoxTitle=%EC%82%BC%EC%84%B1+%EC%8B%A0%EC%9E%85+%EB%AA%A8%EC%9D%98+sw+%EC%97%AD%EB%9F%89%ED%85%8C%EC%8A%A4%ED%8A%B8+%EB%AC%B8%EC%A0%9C%EB%AA%A8%EC%9D%8C&problemBoxCnt=10)

## `Problem`
> 문제정의
- `INPUT:`
- `OUTPUT:`

- `Condition(주의할 문제조건)`
    - `cond1:`탈주범은 탈출한 지 한 시간 뒤, 움직인다.
    - `cond2:`세로 크기 N, 가로 크기 M은 각각 5 이상 50 이하이다. (5 ≤ N, M ≤ 50) **정사각형이 아니다**
    - `cond3`: 지하 터널 지도에는 반드시 1개 이상의 터널이 있음이 보장된다.
    - `cond4`: 숫자 1 ~ 7은 해당 위치의 터널 구조물 타입을 의미하며 숫자 0 은 터널이 없는 장소를 의미
## `1st try`
- **`Before try`(`접근법`)**

  - `Variables(변수: 데이터타입)`
  - `Algorithm`
```
start 포인트에서 해당 구조물을 따라서 L만큼 dfs를 돌린다.
- result = max(result,cnt+1)
```
```python
def is_shape_match(cur,target):
    return (cur[0]*-1,cur[1]*-1) in TUNNEL_MAP[TUNNEL[target[0]][target[1]]]

def is_idx_in_bound(y,x):
    global N,M
    return 0<=y<N and 0<=x<M
        
def dfs(node,cnt=0):
    global L,result_set
    y,x = node
    # visit
    VISITED[y][x] = True
    cnt+=1
    # base condition
    if cnt != L:
        for nxt in TUNNEL_MAP[TUNNEL[y][x]]:
            nxt_y,nxt_x = y+nxt[0],x+nxt[1]
            # match 확인해야함(현재에서 갈 수 있으며, next의 shape가 받을 수 있어야함)
            if (is_idx_in_bound(nxt_y,nxt_x) and
                    not VISITED[nxt_y][nxt_x] and
                    TUNNEL[nxt_y][nxt_x] != '0'):
                if is_shape_match(nxt,(nxt_y,nxt_x)):    # if match
                    result_set.add((nxt_y,nxt_x))   # result update
                    dfs((nxt_y,nxt_x),cnt)
    # unvisit
    VISITED[y][x] = False

if __name__ == '__main__':
    TRY = int(input())
    TUNNEL_MAP = {
        '1':[(0,1),(0,-1),(1,0),(-1,0)],
        '2':[(1,0),(-1,0)],
        '3':[(0,1),(0,-1)],
        '4':[(0,1),(-1,0)],
        '5':[(0,1),(1,0)],
        '6':[(0,-1),(1,0)],
        '7':[(0,-1),(-1,0)],
    }
    for t in range(TRY):
        # input
        N,M,R,C,L = map(int,input().split())
        TUNNEL = [input().split() for i in range(N)]
        VISITED = [[False,]*M for i in range(N)]
        result_set = set()
        result_set.add((R,C))
        
        dfs((R,C))
        # Output print
        print("#"+str(t+1),end=' ')
        print(len(result_set))
```

- **After try(회고)**
    - dfs를 돌면서 한번도 가지 못한 곳은 result에 넣어주어야 한다.
        - 그리하여 result를 `set()`으로 생성하고 move가능할때마다, set에다가 넣어주었다.
        - **혹시 더 깔끔하게 uniq한 (y,x)를 저장하는 방법 없을까?**
